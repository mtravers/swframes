Ideas.

In-memory and SPARQL endpoints should have a common (or partially common) API.  

In-memory frames can have slot indexes for quicker lookup. But we probably don't
want to make a whole in-memory SPARQL implementation (or maybe we do, it's not
that hard).

Theory of dirtiness (Not yet implemented):
- frames have a slot of dirty predicates.
- there is a global (or per-sparql) list of dirty frames

Theory of blank nodes (and also, perhaps, fresh frames)
- they don't need a unique URI
- fresh frames don't need to have a unique URI until they are written out somewhere

Theory of slot values
- always a list
- should deprecate set-slotv, add-triple is the appropriate API
- should keep inverses
- msv is a more abstracted form of slotv that works on lists

- should use rdfs typing
- should make clos classes to rdfs
- should have option for domain/range checking based on rdf

- need theory of serialized lisp objects.  SPARQL basically always returns strings or URIs; some strings should
  be READ.

----------------------------------------------------------------------------------

History Structure:

- Linear list of chunks
- chunks can have subchunks
  - so a function and its response are separate related chunks
- chunks can be typed
   - use rdfs types?  probably, maybe chunk -> content -> typed thing
- SEXP chunks - get evaluated
- ASK chunks - get sent to the collective Oracle
- FORM chunks - also get evaluated
others?
